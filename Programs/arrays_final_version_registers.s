	.intel_syntax noprefix
	.text
	.section	.rodata
.LC0:
	.string	"%d"
	.text

input:
	push	rbp				# Пролог функции
	mov	rbp, rsp
	sub	rsp, 32
	
	push rbx
	push r12
	push r13
	push r14
	
	mov	rbx, rdi			# Кладем в rbx указатель на массив (первый формальный аргумент функции)
	mov	r12, rsi			# Кладем в r12 значение из rsi - значение int size (второй формальный аргумент функции)
	
	mov	r13, 0				# Кладем в r13 ноль (счетчик int i = 0 в arrays.c)
	jmp	.L2				# Безусловный переход к метке .L2
	
.L3:		
	lea	rsi, [rbx] 			# Положили адрес нужной ячейки
	lea	rdi, .LC0[rip]			# Кладем в регистр rax информацию, что будет вводиться целое число
	mov	eax, 0
	call	__isoc99_scanf@PLT		# Вызываем встроенный в Си scanf - ввод числа (scanf("%d", &(arr[i]))
	
	add	rbx, 8				# Переходим в следующей ячейке массива
	add	r13, 1				# Увеличиваем значение счетчика на единицу
.L2:
	cmp	r13, r12			# Сравниваем значение в r13 (счетчик) с значением переменной size
	jl	.L3				# Если значение в r13 меньше значения size, то переходим к метке .L3
	
.L4:
	pop r14
	pop r13
	pop r12
	pop rbx

	add rsp, 32				# Эпилог функции
	mov rsp, rbp
	pop rbp
	ret

getMax:
	push	rbp				# Пролог функции
	mov	rbp, rsp
	
	push rbx
	push r12
	push r13
	push r14
	
	mov	eax, [rdi]			
	movsx	rbx, eax			# Кладем в rbx первый элемент массива int *arr (текущий максимум)					
	mov	r12, rsi			# Кладем в r12 значение из rsi - значение int size (второй формальный аргумент функции)
	
	mov	r13, 1				# Счетчик (int i = 1)
	jmp	.L6				# Безусловный переход к метке .L6
.L8:
	add	rdi, 8				# Переход к следующей ячейке памяти
	mov	eax, [rdi]
	movsx	r14, eax			# Кладем в r14 текущий элемент массива
	cmp	rbx, r14			# Сравниваем текущий максимум с текущим элементом массива
	jge	.L7				# Если текущий максимум больше либо равен, чем текущий элемент массива, то переходим к метке .L7

	mov eax, [rdi]
	movsx	rbx, eax			# Иначе обновляем максимум
.L7:
	add	r13, 1				# Добавляем к счетчику 1
.L6:
	cmp	r13, r12			# Сравниваем текущее значение счетчика с размером массива
	jl	.L8				# Если текущее значение счетчика меньше размера массива, то переходим к метке .L8
	
	mov	rax, rbx			# В rax кладем найденный максимум
	
	pop r14
	pop r13
	pop r12
	pop rbx
	
	pop	rbp				# Эпилог функции
	ret

changeArray:
	push	rbp				# Пролог функции
	mov	rbp, rsp
	
	push rbx
	push r12
	push r13
	push r14
	
	mov r13, rdx
	
	mov	r14, 0				# Определяем счетчик цикла, присваиваем ему ноль
	jmp	.L11				# Безусловный переход к метке .L11
.L14:
	mov	eax, [rdi]			
	movsx	r12, eax			# Кладем в регистр r12 текущее значение int *arr
	cmp	r12, 0				# Сравниваем текущий элемент массива int *arr с нулем
	jge	.L12				# Если текущий элемент массива больше либо равен нулю, то переходим к метке .L12
	mov	[rsi], r13			# Иначе текущему элементу массива int *сhanged_arr присваиваем максимум массива int *arr
	jmp	.L13				# Безусловный переход к метке .L13
.L12:
	mov	[rsi], r12			# В текущий элемент массива int *changed_arr кладем текущий элемент массива int *arr
.L13:
	add	r14, 1				# Добавляем к счетчику 1
	add	rdi, 8				# Переход к следующей ячейке массива int *arr
	add	rsi, 8				# Переход к следующей ячейке массива int *changed_arr
.L11:
	cmp	r14, rcx			# Сравниваем значением счетчика с размером массива
	jl	.L14				# Если значение счетчика меньше, чем размер массива, то переходим в метке .L14
	nop
	nop
	
	pop r14
	pop r13
	pop r12
	pop rbx
	
	pop	rbp				# Эпилог функции
	ret

	.section	.rodata
.LC1:
	.string	"%d "
	.text

output:
	push	rbp				# Пролог функции
	mov	rbp, rsp
	sub	rsp, 32
	
	push rbx
	push r12
	push r13
	push r14
	
	mov	rbx, rdi			# Кладем в rbx указатель на первый элемент массива int *arr - первый формальный параметр функции
	mov	r12, rsi			# Кладем в r12 значение int size (размер массива) - второй формальный параметр функции
	mov	r14, 0				# Определяем счетчик, изначально равен нулю
	jmp	.L16				# Безусловный переход к метке .L16
.L17:
	mov	rsi, [rbx]			# Кладем в регистр rsi текущий элемент массива int *arr
	lea	rdi, .LC1[rip]			# Кладем в rdi информацию о том, что будет выводиться целое число
	mov	eax, 0
	call	printf@PLT			# Вызов функции printf определенной в языке Си - печать числа
	add	r14, 1				# Добавляем к счетчику 1
	add	rbx, 8				# Переходим к следующей ячейке массива int *arr
.L16:
	cmp	r14, r12			# Сравниваем значением счетчика с размером массива
	jl	.L17				# Если значение счетчика меньше, чем размер массива, то переходим в метке .L17
	
	mov	edi, 10				# Кладем в edi значение '\n' - переход на новую строку
	call	putchar@PLT			# Вызываем printf cо значением, находящемся в edi - '\n'
	nop
	
	pop r14
	pop r13
	pop r12
	pop rbx
	
	add rsp, 32				# Эпилог функции
	mov rsp, rbp
	pop rbp
	ret


	.section	.rodata
.LC2:
	.string	"Incorrect length"
	.text
	.globl	main
main:
	push	rbp				# Пролог функции
	mov	rbp, rsp
	sub	rsp, 40
	
	push rbx
	push r12
	push r13
	push r14
	push r15
	
	mov	rax, QWORD PTR fs:40
	mov	QWORD PTR -8[rbp], rax
	xor	eax, eax
	
	lea	rax, -32[rbp]			# Кладем в регистр rax адрес, по которому будет находиться переменная size (из программы arrays.c)
	mov	rsi, rax			# Кладем в регистр rsi значение rax (адрес переменной size)
	lea	rax, .LC0[rip]			# Кладем в регистр rax информацию о том, что будет подано на вход целое число
	mov	rdi, rax			# Кладем в регистр rdi значение rax (информация, что будет подано целое число)
	mov	eax, 0
	call	__isoc99_scanf@PLT		# Вызов функции scanf из языка Си. - ввод размера массива
	
	mov ebx, DWORD PTR -32[rbp]		# Кладем в регистр ebx значение переменной size
	movsx rbx, ebx				# Кладем в rbx значение регистра ebx (int size)
	
	mov	rax, rbx			# Кладем в регистр rax значение из регистра rbx - значение size (из программы arrays.c)
	test	rax, rax			# Проверяем, равно ли значение в rax нулю
	js	.L19				# Если значение меньше нуля, то переходим к метке .L19
	
	mov	rax, rbx			# Кладем в регистр rax значение из регистра rbx - значение size (из программы arrays.c)
	cmp	rax, 100000			# Сравниваем значение с значением 100000
	jle	.L20				# Если оно меньше или равно 100000, то переходим к метке .L20
	
.L19:
	lea	rax, .LC2[rip]			# Кладем в регистр rax адрес строки, содержащую информацию о некорректном вводе.
	mov	rdi, rax			# Кладем в регистр rdi значение регистр rax
	mov	eax, 0
	call	printf@PLT			# Вызов функции printf из языка Си - печатаем сообщение о некорректном вводе
	jmp	.L21				# Безусловный переход в метке .L21
.L20:
	mov	rax, rbx			# Кладем в регистр rax значение из регистра rbx - значение size (из программы arrays.c)
	sal	rax, 3				# Побитовый сдвиг
	mov	rdi, rax			# Кладет в регистр rdi значение, находящееся в регистре rax (переменная size)
	call	malloc@PLT			# Вызов malloc из языка Си (динамическое выделение памяти для первого массива)
	
	mov	r12, rax			# Кладет в r12 значение из rax. (переменная int *start_array из arrays.c)
	
	mov	rsi, rbx			# Кладет в регистр rsi значение из регистра rbx (значение переменной size) - второй фактический аргумент функции
	mov	rdi, r12			# Кладет в регистр rdi значение регистр r12 (указатель на начало массива *start_array из arrays.c) - первый фактический аргумент функции
	call	input				# Вызов функции input, которая была написана при разработке программы arrays.c (пользователь заполняет массив числами)
	
	mov	rsi, rbx			# Кладет в регистр  rsi значение регистра rbx (переменная size) - второй фактический аргумент функции
	mov	rdi, r12			# Кладет в регистр rdi значение регистр r12 (указатель на начало массива *start_array из arrays.c) - первый фактический аргумент функции
	call	getMax				# Вызов функции getMax, которая была написана при разработке программы arrays.c (поиск максимума в начальном массиве)
	
	mov	r13, rax			# В r13 кладем найденный максимум из регистра rax
	
	mov	rax, rbx			# В регистр rax кладем значение переменной size
	sal	rax, 3				# Побитовый сдвиг значения
	mov	rdi, rax			# Кладем в rdi значение пермеменной size из регистра rax - первый аргумент
	call	malloc@PLT			# Вызываем  malloc - встроенную в Си функцию (динамически выделяем память для второго массива)
	
	mov	r14, rax			# В r14 кладем указатель на первый элемент массива int *final_array (переменная из программы на языке Си) из регистра rax 
	
	mov	rcx, rbx			# Кладем в регистр rcx значение переменной size (из программы на языке Си) - четвертый фактический аргумент вызываемой функции
	mov	rdx, r13			# В регистр rdx кладем найденный максимум - третий фактический аргумент вызываемой функции
	mov	rsi, r14			# В регистр rsi кладем указатель на первый элемент массива int *final_array - второй фактический аргумент вызываемой функции
	mov	rdi, r12			# В регистр rdi кладем значение регистра rax (указатель на первый элемент массива int *start_array) - первый фактический аргумент вызываемой функции
	call	changeArray			# Вызываем функцию changeArray, написанную в программе arrays.c (получение нового массива, согласно условию задачи)
	
	mov	rsi, rbx			# В регистр rsi кладем значение регистра rbx (размер массива) -  второй фактический аргумент вызываемой функции
	mov	rdi, r14			# В регистр rdi кладем указатель на первый элемент массива int *final_array -  первый фактический аргумент вызываемой функции
	call	output				# Вызов функции output, которая была написана при разработке программы arrays.c (вывод полученного массива)
	
	mov	rdi, r12			# В регистр rdi кладем указатель на первый элемент массива int *start_array (значение регистра rax)
	call	free@PLT			# Очищаем память, выделенную под первый массив
	
	mov	rdi, r14			# В регистр rdi кладем указатель на первый элемент массива int *final_array (значение регистра rax)
	call	free@PLT			# Очищаем память, выделенную под второй массив
.L21:
	mov	eax, 0				# Кладем 0 в eax (программа завершена успешно)
	mov	rdx, QWORD PTR -8[rbp]
	sub	rdx, QWORD PTR fs:40
	je	.L23
	call	__stack_chk_fail@PLT
.L23:					
	pop r15
	pop r14
	pop r13
	pop r12
	pop rbx
	
	add rsp, 40				# Эпилог функции, заверешние программы с кодом 0
	mov rsp, rbp
	pop rbp
	ret
